<html>
<head>
<style>
body { margin: 0; padding: 0; }
#viewport { overflow: scroll; width: 95% }
#backbuffer { display: none; }
#canvas { clear: both; padding: 0 }

#debug { color:white; font-size: 80%; width: 48%; background-color: #333}
#debug2 { color:white; width: 48%; float: right; background-color: #333}
body { background-color: black;}
</style>
</head>
<body>
  <div id="viewport">
    <canvas id="backbuffer"></canvas>
    <canvas id="canvas"></canvas>
    <div>
      <div id="debug2"></div>
      <div id="debug"></div>
    </div>
  </div>
<script>
// block data
class Block {
  constructor(copy) {
    if (copy) {
      this.fg = copy.fg;
      this.bg = copy.bg;
      this.pix = Array.apply(null, Array(8)).map((x,i) => {return copy.pix[i];});
    } else {
      this.fg = 1;
      this.bg = 0;
      this.pix = Array.apply(null, Array(8)).map(() => {return 0;});
    }
  }

  clear() {
    this.fg = 1;
    this.bg = 0;
    this.pix.fill(0);
  }

  random() {
    this.fg = Math.floor(Math.random() * 16);
    this.bg = Math.floor(Math.random() * 16);
    this.pix = Array.apply(null, Array(8)).map(() => {return Math.floor(Math.random() * 256);;});
  }

  setPixel(x, y, color) {
    var sum = this.pix.reduce((sum, v) => { return sum + v;});
    if (sum == 0) {
      this.fg = color;
      this.pix[y] += (1 << (7-x));
    }
    else if (sum == 255 * 8) {
      this.bg = color;
      this.pix[y] -= (1 << (7-x));
    }
    else {
      var is_set = this.pix[y] & (1 << (7-x));
      if (is_set) {
        if (this.bg == color)
          // set to background color
          this.pix[y] -= (1 << (7-x));
        else
          // change foreground color
          this.fg = color;
      }
      else {
        if (this.fg == color)
          // set to foreground color
          this.pix[y] += (1 << (7-x));
        else
          // change background color
          this.bg = color;
      }
    }
  }
}

// size of canvas in blocks
var nbx = 320/8, nby = 200/8;

// image data
var image;

// restore image or set up new empty image
(function() {
  var data = window.localStorage.getItem('current_image');
  if (data) {
    // restore from localStorage
    restoreImage(data);
  } else {
    // new empty image
    image = Array.apply(null, Array(nbx * nby)).map(() => {return new Block;});
  }
})();

// html canvases
var backbuffer = document.getElementById('backbuffer');
var canvas = document.getElementById('canvas');
backbuffer.width = nbx * 8;
backbuffer.height = nby * 8;

// rendering contexts
var ctx = backbuffer.getContext('2d');
var frontctx = canvas.getContext('2d');

// rendering block buffer
var bbuf = ctx.createImageData(8, 8);

// draw gridlines?
var grid = true;

// palette
palette = [
    { "red": 0,   "green": 0,   "blue": 0,   "name": "black"       },
    { "red": 255, "green": 255, "blue": 255, "name": "white"       },
    { "red": 104, "green": 55,  "blue": 43,  "name": "red"         },
    { "red": 112, "green": 164, "blue": 178, "name": "cyan"        },
    { "red": 111, "green": 61,  "blue": 134, "name": "purple"      },
    { "red": 88,  "green": 141, "blue": 67,  "name": "green"       },
    { "red": 53,  "green": 40,  "blue": 121, "name": "blue"        },
    { "red": 184, "green": 199, "blue": 111, "name": "yellow"      },
    { "red": 111, "green": 79,  "blue": 37,  "name": "orange"      },
    { "red": 67,  "green": 57,  "blue": 0,   "name": "brown"       },
    { "red": 154, "green": 103, "blue": 89,  "name": "light red"   },
    { "red": 68,  "green": 68,  "blue": 68,  "name": "dark grey"   },
    { "red": 108, "green": 108, "blue": 108, "name": "grey"        },
    { "red": 154, "green": 210, "blue": 132, "name": "light green" },
    { "red": 108, "green": 94,  "blue": 181, "name": "light blue"  },
    { "red": 149, "green": 149, "blue": 149, "name": "light grey"  }
];

// current fg color index for drawing
var fg = 1, bg = 0;

// preview block
var preview;

// draw a single Block
function drawBlock(bx, by, block)
{
  var byte, bit, idx = 0, col;
  for (byte = 0; byte < 8; ++byte)
    for (bit = 7; bit >= 0; --bit)
    {
      is_set = block.pix[byte] & (1 << bit);
      if (is_set)
        col = block.fg;
      else
        col = block.bg;

      bbuf.data[idx++] = palette[col].red;
      bbuf.data[idx++] = palette[col].green;
      bbuf.data[idx++] = palette[col].blue;
      bbuf.data[idx++] = 255;
    }

  // ctx.putImageData(bbuf, bx * 8, (nby - by - 1) * 8);
  ctx.putImageData(bbuf, bx * 8, by * 8);
}

// update front buffer
function updateFrontBuffer()
{
  // upscale without interpolation
  frontctx.imageSmoothingEnabled = false;
  frontctx.drawImage(backbuffer, 0, 0, backbuffer.width, backbuffer.height, 0, 0, canvas.width, canvas.height);

  // draw gridlines
  if (grid) {
    var space = 8 * (1 << zoom);
    var bx, by;

    frontctx.imageSmoothingEnabled = true;
    frontctx.lineWidth = 0.5;
    for (bx = 0; bx <= nbx; ++bx) {
      frontctx.beginPath();
      frontctx.moveTo(bx * space, 0)
      frontctx.lineTo(bx * space, (nbx+1) * space);
      frontctx.strokeStyle = 'white';
      frontctx.stroke();
      frontctx.strokeStyle = 'black';
      frontctx.stroke();
    }
    for (by = 0; by <= nbx; ++by) {
      frontctx.beginPath();
      frontctx.moveTo(0, by * space)
      frontctx.lineTo((nbx+1) * space, by * space);
      frontctx.strokeStyle = 'white';
      frontctx.stroke();
      frontctx.strokeStyle = 'black';
      frontctx.stroke();
    }
  }
}

// clear image
function clear()
{
  for (by = 0; by < nby; ++by)
    for (bx = 0; bx < nbx; ++bx)
      image[bx + by * nbx].clear();
}

// randomize image
function randomize()
{
  for (by = 0; by < nby; ++by)
    for (bx = 0; bx < nbx; ++bx)
      image[bx + by * nbx].random();
}

// redraw image
function redraw()
{
  var bx, by;
  for (by = 0; by < nby; ++by)
    for (bx = 0; bx < nbx; ++bx)
      drawBlock(bx, by, image[bx + by * nbx]);
  updateFrontBuffer();
}

// set a pixel at given coordinates using an block object
function setPixel(px, py, color, draw) {
  var bx = px >> 3, by = py >> 3;
  var block;
  if (draw) {
    block = image[bx + by * nbx];
  } else {
    block = new Block(image[bx + by * nbx]);
  }
  block.setPixel(px % 8, py % 8, color)
  drawBlock(bx, by, block);
}


// serialize image for exporting and emergency save
function serializeImage()
{
  var i, j, blocks = nbx * nby;
  var size =  blocks * 9 + 2;
  buf = new Uint8Array(new ArrayBuffer(size));
  // header (width and height)
  buf[0] = nbx;
  buf[1] = nby;

  // serialize fg/bg data
  for (i = 0; i < blocks; ++i)
    buf[i+2] = image[i].fg + (image[i].bg << 4);

  // serialize bitmap data
  for (i = 0; i < blocks; ++i)
    for (j = 0; j < 8; ++j)
      buf[i*8+j+blocks+2] = image[i].pix[j];

  return window.btoa(buf);
}

// serialize image for exporting and emergency save
function restoreImage(data)
{
  var buf = new Uint8Array(JSON.parse('[' + window.atob(data) + ']'));
  // header (width and height)
  nbx = buf[0];
  nby = buf[1];

  var i, j, blocks = nbx * nby;
  var size =  blocks * 9 + 2;
  if (buf.length != size) {
    alert("Corrupt image data");
  }
  image = Array.apply(null, Array(blocks)).map(() => {return new Block;});

  // unserialize fg/bg data
  for (i = 0; i < blocks; ++i) {
    image[i].fg = buf[i+2] % 16
    image[i].bg = buf[i+2] >> 4;
  }

  // unserialize bitmap data
  for (i = 0; i < blocks; ++i)
    for (j = 0; j < 8; ++j)
      image[i].pix[j] = buf[i*8+j+blocks+2];
}

// undo data
var undodata = [], undocurrent;
var undopointer = 0;

function undo() {
  if (undopointer > 0) {
    if (undopointer == undodata.length) {
      // save current state if we at the end of the undo chain
      undocurrent = serializeImage();
    }
    undopointer--;
    restoreImage(undodata[undopointer]);
  }
}
function redo() {
  if (undopointer < undodata.length) {
    undopointer++;
    if (undopointer == undodata.length) {
      restoreImage(undocurrent);
    } else {
      restoreImage(undodata[undopointer]);
    }
  }
}
function saveHistory() {
  undodata[undopointer] = serializeImage();
  undopointer++;
  // remove redo steps beyond this state
  undodata.splice(undopointer);
}

// zoom factor
var zoom;
function setZoom(z)
{
  if (zoom !== z) {
    zoom = z;
    canvas.width = backbuffer.width * (1 << zoom);
    canvas.height = backbuffer.height * (1 << zoom);
    updateFrontBuffer();
  }
}

// debug events
var dspan = document.getElementById("debug");
var dspan2 = document.getElementById("debug2");
var estat = {};
function filterHostObject(e)
{
  var o = {}, t, a, i, key;

  if (e === null || e === undefined)
    return e;

  for (key in e) {
    if (e[key] instanceof Node) {
      o[key] = '((Node))';
    }
    else if (e[key] instanceof Window) {
      o[key] = '((Window))';
    }
    else if (e[key] instanceof Function) {
      o[key] = '((Function))';
    }
    else {
      t = typeof e[key];
      if (t==='number' || t==='string' || t==='boolean' ) {
        o[key] = e[key]
      }
      else if (t==='object') {
        o[key] = filterHostObject(e[key]);
      }
      else if (t==='array') {
        o[key] = [];
        a = filterHostObject(e[key])
        for (i in a)
          o[i] = a[i];
      }
      else {
        o[key] = '(' + t + ')';
      }
    }
  }
  return o;
}
function printEvent(e)
{
  dspan.innerText = JSON.stringify(filterHostObject(e), (k,v) => {return v;}, ' ');
  var n = estat[e.type] || 0;
  estat[e.type] = n + 1;
  dspan2.innerText = JSON.stringify(estat, (k,v) => {return v;}, ' ');
}

// pixel coordinates
var px, py;

// current tool
var tool = 0;

// dragging the mouse?
var dragging = false;

// block list to restore
var restore = [];
function saveBlock(px, py) {
  restore.push({x: (px >> 3), y: (py >> 3)});
}
function restoreBlocks()
{
  var i;
  for (i=0; i<restore.length; ++i)
    drawBlock(restore[i].x, restore[i].y, image[restore[i].x + restore[i].y * nbx]);
  restore = [];
}

// add keyboard event listener
document.addEventListener('keydown', (e) => {
  if (e.keyCode >= 48 && e.keyCode < 56) {
    fg = e.keyCode - 48;
    if (e.shiftKey)
      fg += 8;
  }
  else if (e.key === 'g') {
    grid = !grid;
    updateFrontBuffer();
  }
  else if (e.key === 'C') {
    saveHistory();
    clear();
    redraw();
  }
  else if (e.key === 'u') {
    undo();
    redraw();
  }
  else if (e.key === 'y') {
    redo();
    redraw();
  }
  else if (e.key === 'R') {
    saveHistory();
    randomize();
    redraw();
  }
  else if (e.key === '+') {
    setZoom(zoom+1)
  }
  else if (e.key === '-' && zoom > 0) {
    setZoom(zoom-1)
  }

  // else console.log(e);
});

// process mouse event
function processMouseEvent(e)
{
  var pxn = Math.floor(e.offsetX / (1 << zoom));
  var pyn = Math.floor(e.offsetY / (1 << zoom));

  // mouse has not moved
  if (e.type == 'mousemove' && pxn === px && pyn === py)
    return;

  px = pxn;
  py = pyn;

  if (tool === 0) { // pixel draw
    if (e.buttons === 0) { // preview
      restoreBlocks();
      saveBlock(px, py);
      setPixel(pxn, pyn, fg, false);
      updateFrontBuffer();
    }
    else if (e.buttons === 1) { // fg
      setPixel(pxn, pyn, fg, true);
      updateFrontBuffer();
    }
    else if (e.buttons === 2) { // bg
      setPixel(pxn, pyn, bg, true);
      updateFrontBuffer();
    }
  }
  e.preventDefault();
  e.stopPropagation();
}

// add mouse listeners
canvas.addEventListener('touchmove', (e) => {
  printEvent(e);
  e.preventDefault();
  e.stopPropagation();
});
canvas.addEventListener('touchstart', (e) => {
  printEvent(e);
  e.preventDefault();
  e.stopPropagation();
});
canvas.addEventListener('touchend', (e) => {
  printEvent(e);
  e.preventDefault();
  e.stopPropagation();
});
canvas.addEventListener('mousedown', (e) => {
  dragging = true;
  processMouseEvent(e);
});
canvas.addEventListener('mousemove', (e) => {
  processMouseEvent(e)
});
document.addEventListener('mouseup', (e) => {
  dragging = false;
  e.preventDefault();
  e.stopPropagation();
});
canvas.addEventListener('contextmenu', function(evt) {
  evt.preventDefault();
}, false);

// add system events
window.addEventListener('beforeunload', (e) => {
  window.localStorage.setItem('current_image', serializeImage());
});

setZoom(2);
redraw();

</script>
</body>
</html>
